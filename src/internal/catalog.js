// Code generated by mpackc.
// Do not edit.

import {Any, Arr, Bool, Int, Map, Str, TypedArr, TypedMap, Uint} from "messagepack";


// Catalog holds the data for a message catalog which included localized
// messages and the locale information needed to format numbers and plurals.
export const Catalog = {
	enc(buf, v) {
		Map.encHeader(buf, 3);
		Int.enc(buf, 1);
		Int.enc(buf, v.version);
		Int.enc(buf, 2);
		Locale.enc(buf, v.locale);
		Int.enc(buf, 3);
		_MessageArr.enc(buf, v.messages);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // version
				res.version = Int.dec(buf); break;
			case 2: // locale
				res.locale = Locale.dec(buf); break;
			case 3: // messages
				res.messages = _MessageArr.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// Symbols holds all symbols that are used to format a number in a specific locale.
export const Symbols = {
	enc(buf, v) {
		Map.encHeader(buf, 7);
		Int.enc(buf, 1);
		Str.enc(buf, v.decimal);
		Int.enc(buf, 2);
		Str.enc(buf, v.group);
		Int.enc(buf, 3);
		Str.enc(buf, v.percent);
		Int.enc(buf, 4);
		Str.enc(buf, v.minus);
		Int.enc(buf, 5);
		Str.enc(buf, v.inf);
		Int.enc(buf, 6);
		Str.enc(buf, v.nan);
		Int.enc(buf, 7);
		Uint.enc(buf, v.zero);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // decimal
				res.decimal = Str.dec(buf); break;
			case 2: // group
				res.group = Str.dec(buf); break;
			case 3: // percent
				res.percent = Str.dec(buf); break;
			case 4: // minus
				res.minus = Str.dec(buf); break;
			case 5: // inf
				res.inf = Str.dec(buf); break;
			case 6: // nan
				res.nan = Str.dec(buf); break;
			case 7: // zero
				res.zero = Uint.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// NumberFormat holds all relevant information to format a number in a specific locale.
export const NumberFormat = {
	enc(buf, v) {
		Map.encHeader(buf, 11);
		Int.enc(buf, 1);
		Symbols.enc(buf, v.symbols);
		Int.enc(buf, 2);
		Str.enc(buf, v.positivePrefix);
		Int.enc(buf, 3);
		Str.enc(buf, v.positiveSuffix);
		Int.enc(buf, 4);
		Str.enc(buf, v.negativePrefix);
		Int.enc(buf, 5);
		Str.enc(buf, v.negativeSuffix);
		Int.enc(buf, 6);
		Int.enc(buf, v.minIntegerDigits);
		Int.enc(buf, 7);
		Int.enc(buf, v.minFractionDigits);
		Int.enc(buf, 8);
		Int.enc(buf, v.maxFractionDigits);
		Int.enc(buf, 9);
		Int.enc(buf, v.primaryIntegerGrouping);
		Int.enc(buf, 10);
		Int.enc(buf, v.secondaryIntegerGrouping);
		Int.enc(buf, 11);
		Int.enc(buf, v.fractionGrouping);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // symbols
				res.symbols = Symbols.dec(buf); break;
			case 2: // positivePrefix
				res.positivePrefix = Str.dec(buf); break;
			case 3: // positiveSuffix
				res.positiveSuffix = Str.dec(buf); break;
			case 4: // negativePrefix
				res.negativePrefix = Str.dec(buf); break;
			case 5: // negativeSuffix
				res.negativeSuffix = Str.dec(buf); break;
			case 6: // minIntegerDigits
				res.minIntegerDigits = Int.dec(buf); break;
			case 7: // minFractionDigits
				res.minFractionDigits = Int.dec(buf); break;
			case 8: // maxFractionDigits
				res.maxFractionDigits = Int.dec(buf); break;
			case 9: // primaryIntegerGrouping
				res.primaryIntegerGrouping = Int.dec(buf); break;
			case 10: // secondaryIntegerGrouping
				res.secondaryIntegerGrouping = Int.dec(buf); break;
			case 11: // fractionGrouping
				res.fractionGrouping = Int.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// PluralTag is an enumeration of supported plural types. Each plural tag
// can have its own translation text.
export const PluralTag = Int

// Operand represents an operand in a plural rule.
export const Operand = Int

// Connective represents a logical connective for two plural rules. A plural rule
// can be connected with another rule by a conjunction ('and' operator) or a
// disjunction ('or' operator). The conjunction binds more tightly.
export const Connective = Int

// Range represents an integer range, where both bounds are inclusive.
// If the lower bound equals the upper bound, the range will collapse
// to a single value.
export const Range = {
	enc(buf, v) {
		Map.encHeader(buf, 2);
		Int.enc(buf, 1);
		Int.enc(buf, v.lowerBound);
		Int.enc(buf, 2);
		Int.enc(buf, v.upperBound);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // lowerBound
				res.lowerBound = Int.dec(buf); break;
			case 2: // upperBound
				res.upperBound = Int.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// PluralRule holds the data for a single plural rule. The Modulo field defines the
// modulo divisor for the operand. If Modulo is zero, no remainder has to be calculated.
//
// The plural rule could be connected with another rule. If so, the Connective field is
// set to the respective value (Conjunction or Disjunction). Otherwise the Connective
// field is set to None and there is no follow-up rule.
//
// Example for a plural rule: i%10=1..3
export const PluralRule = {
	enc(buf, v) {
		Map.encHeader(buf, 5);
		Int.enc(buf, 1);
		Operand.enc(buf, v.operand);
		Int.enc(buf, 2);
		Int.enc(buf, v.modulo);
		Int.enc(buf, 3);
		Bool.enc(buf, v.negate);
		Int.enc(buf, 4);
		_RangeArr.enc(buf, v.ranges);
		Int.enc(buf, 5);
		Connective.enc(buf, v.connective);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // operand
				res.operand = Operand.dec(buf); break;
			case 2: // modulo
				res.modulo = Int.dec(buf); break;
			case 3: // negate
				res.negate = Bool.dec(buf); break;
			case 4: // ranges
				res.ranges = _RangeArr.dec(buf); break;
			case 5: // connective
				res.connective = Connective.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// Plural represents a single plural form. It holds a collection of plural rules
// for a specific plural tag where all rules are connected with each other (see
// Rule and Connective).
export const Plural = {
	enc(buf, v) {
		Map.encHeader(buf, 2);
		Int.enc(buf, 1);
		PluralTag.enc(buf, v.tag);
		Int.enc(buf, 2);
		_PluralRuleArr.enc(buf, v.rules);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // tag
				res.tag = PluralTag.dec(buf); break;
			case 2: // rules
				res.rules = _PluralRuleArr.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// Locale holds the data which is necessary to format data in a region
// specific format.
export const Locale = {
	enc(buf, v) {
		Map.encHeader(buf, 6);
		Int.enc(buf, 1);
		Str.enc(buf, v.id);
		Int.enc(buf, 2);
		NumberFormat.enc(buf, v.decimalFormat);
		Int.enc(buf, 3);
		NumberFormat.enc(buf, v.moneyFormat);
		Int.enc(buf, 4);
		NumberFormat.enc(buf, v.percentFormat);
		Int.enc(buf, 5);
		_PluralArr.enc(buf, v.cardinalPlurals);
		Int.enc(buf, 6);
		_PluralArr.enc(buf, v.ordinalPlurals);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // id
				res.id = Str.dec(buf); break;
			case 2: // decimalFormat
				res.decimalFormat = NumberFormat.dec(buf); break;
			case 3: // moneyFormat
				res.moneyFormat = NumberFormat.dec(buf); break;
			case 4: // percentFormat
				res.percentFormat = NumberFormat.dec(buf); break;
			case 5: // cardinalPlurals
				res.cardinalPlurals = _PluralArr.dec(buf); break;
			case 6: // ordinalPlurals
				res.ordinalPlurals = _PluralArr.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// Message holds the data for a single message. Each message contains of
// a list of fragments which has to be concatenated to receive the message
// test. If the message does not contain any replacement variables, there
// will only be one string fragment.
export const Message = {
	enc(buf, v) {
		Map.encHeader(buf, 4);
		Int.enc(buf, 1);
		Str.enc(buf, v.section);
		Int.enc(buf, 2);
		Str.enc(buf, v.key);
		Int.enc(buf, 3);
		_StrArr.enc(buf, v.text);
		Int.enc(buf, 4);
		_ReplacementArr.enc(buf, v.replacements);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // section
				res.section = Str.dec(buf); break;
			case 2: // key
				res.key = Str.dec(buf); break;
			case 3: // text
				res.text = _StrArr.dec(buf); break;
			case 4: // replacements
				res.replacements = _ReplacementArr.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// Replacement describes a variable piece of text in a message which will be replaced
// during runtime. The key defines the variable's name which will be passed. The type
// contains more details about the particular replacement.
export const Replacement = {
	enc(buf, v) {
		Map.encHeader(buf, 4);
		Int.enc(buf, 1);
		Str.enc(buf, v.key);
		Int.enc(buf, 2);
		Int.enc(buf, v.textPos);
		Int.enc(buf, 3);
		ReplacementType.enc(buf, v.type);
		Int.enc(buf, 4);
		ReplacementDetails.enc(buf, v.details);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // key
				res.key = Str.dec(buf); break;
			case 2: // textPos
				res.textPos = Int.dec(buf); break;
			case 3: // type
				res.type = ReplacementType.dec(buf); break;
			case 4: // details
				res.details = ReplacementDetails.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// ReplacementDetails holds the details for particular replacements. The special Empty
// branch indicates that there a no details for the replacement type.
export const ReplacementDetails = {
	enc(buf, v) {
		Arr.encHeader(buf, 2);
		switch(typeof v) {
		case "object":
			v = v || {};
			if("currency" in v) {
				// MoneyDetails
				Int.enc(buf, 2);
				return MoneyDetails.enc(buf, v);
			}
			if("type" in v && "variants" in v && "custom" in v) {
				// PluralDetails
				Int.enc(buf, 3);
				return PluralDetails.enc(buf, v);
			}
			if("cases" in v && "fallback" in v) {
				// SelectDetails
				Int.enc(buf, 4);
				return SelectDetails.enc(buf, v);
			}
			// EmptyDetails
			Int.enc(buf, 1);
			return EmptyDetails.enc(buf, v);
		default:
			throw new TypeError("invalid union type");
		}
	},

	dec(buf) {
		Arr.decHeader(buf, 2);
		switch(Int.dec(buf)) {
		case 1:
			return EmptyDetails.dec(buf);
		case 2:
			return MoneyDetails.dec(buf);
		case 3:
			return PluralDetails.dec(buf);
		case 4:
			return SelectDetails.dec(buf);
		default :
			throw new TypeError("invalid union type");
		}
	},
};

// ReplacementType describes the type of a replacement. Each type contains the details
// necessary to render the variable's value.
export const ReplacementType = Int

// PluralType is an enumeration for the types of a plural form.
export const PluralType = Int

// EmptyDetails describes a special type for a replacement that has no further
// details attached.
export const EmptyDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 0);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// MoneyDetails contains the replacement details for amounts of money.
export const MoneyDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 1);
		Int.enc(buf, 1);
		Str.enc(buf, v.currency);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // currency
				res.currency = Str.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// PluralDetails contains the replacement details for plurals. Depending on the
// variable, different text for each plural rule can be selected. It contains
// the variants for the supported plural tags and custom overwrites.
export const PluralDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 3);
		Int.enc(buf, 1);
		PluralType.enc(buf, v.type);
		Int.enc(buf, 2);
		_PluralTagMessageMap.enc(buf, v.variants);
		Int.enc(buf, 3);
		_IntMessageMap.enc(buf, v.custom);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // type
				res.type = PluralType.dec(buf); break;
			case 2: // variants
				res.variants = _PluralTagMessageMap.dec(buf); break;
			case 3: // custom
				res.custom = _IntMessageMap.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// SelectDetails contains the replacement details to select a text fragment
// depending on the given variable. The fallback is an optional value which
// describes the default case.
export const SelectDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 2);
		Int.enc(buf, 1);
		_StrMessageMap.enc(buf, v.cases);
		Int.enc(buf, 2);
		Str.enc(buf, v.fallback);
	},

	dec(buf) {
		const res = {};
		let n = Map.decHeader(buf);
		while(n-- > 0) {
			switch(Int.dec(buf)) {
			case 1: // cases
				res.cases = _StrMessageMap.dec(buf); break;
			case 2: // fallback
				res.fallback = Str.dec(buf); break;
			default:
				Any.dec(buf)
			}
		}
		return res;
	},
};

// Required collection types.
const _IntMessageMap = TypedMap(Int, Message);
const _MessageArr = TypedArr(Message);
const _PluralArr = TypedArr(Plural);
const _PluralRuleArr = TypedArr(PluralRule);
const _PluralTagMessageMap = TypedMap(PluralTag, Message);
const _RangeArr = TypedArr(Range);
const _ReplacementArr = TypedArr(Replacement);
const _StrArr = TypedArr(Str);
const _StrMessageMap = TypedMap(Str, Message);
